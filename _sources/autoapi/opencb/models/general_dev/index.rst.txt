opencb.models.general_dev
=========================

.. py:module:: opencb.models.general_dev


Classes
-------

.. autoapisummary::

   opencb.models.general_dev.general_dev


Module Contents
---------------

.. py:class:: general_dev

   This version of the general purpose model will use the tensorplus library to speed things up a bit.
   Also, we'll be fixing a few bugs and adding functionality, particularly when it comes
   to neuron connections.


   .. py:attribute:: device
      :value: 0



   .. py:attribute:: colors
      :value: 255



   .. py:attribute:: size
      :value: 0



   .. py:attribute:: image_size
      :value: 0



   .. py:attribute:: image_map
      :value: 0



   .. py:attribute:: maleability
      :value: 1.1



   .. py:attribute:: range_high
      :value: 2.0



   .. py:attribute:: range_low


   .. py:attribute:: num_controls
      :value: 0



   .. py:attribute:: controls
      :value: 0



   .. py:attribute:: control_thresholds_pos
      :value: 0



   .. py:attribute:: control_thresholds_neg
      :value: 0



   .. py:attribute:: num_sensations
      :value: 0



   .. py:attribute:: sensations
      :value: 0



   .. py:attribute:: neurons
      :value: 0



   .. py:attribute:: thresholds_pos
      :value: 0



   .. py:attribute:: thresholds_neg
      :value: 0



   .. py:attribute:: signals_pos
      :value: 0



   .. py:attribute:: signals_neg
      :value: 0



   .. py:attribute:: emotion1
      :value: 0



   .. py:attribute:: emotion2
      :value: 0



   .. py:attribute:: emotion3
      :value: 0



   .. py:attribute:: emotion4
      :value: 0



   .. py:attribute:: emotion5
      :value: 0



   .. py:attribute:: emotion6
      :value: 0



   .. py:attribute:: emotion7
      :value: 0



   .. py:attribute:: emotion8
      :value: 0



   .. py:attribute:: personality1
      :value: 0



   .. py:attribute:: personality2
      :value: 0



   .. py:attribute:: personality3
      :value: 0



   .. py:attribute:: personality4
      :value: 0



   .. py:attribute:: personality5
      :value: 0



   .. py:attribute:: personality6
      :value: 0



   .. py:attribute:: personality7
      :value: 0



   .. py:attribute:: personality8
      :value: 0



   .. py:attribute:: personality9
      :value: 0



   .. py:attribute:: personality10
      :value: 0



   .. py:attribute:: personality11
      :value: 0



   .. py:attribute:: personality12
      :value: 0



   .. py:attribute:: personality13
      :value: 0



   .. py:attribute:: personality14
      :value: 0



   .. py:attribute:: personality15
      :value: 0



   .. py:attribute:: personality16
      :value: 0



   .. py:attribute:: connections1
      :value: 0



   .. py:attribute:: connections2
      :value: 0



   .. py:attribute:: connections3
      :value: 0



   .. py:attribute:: connections4
      :value: 0



   .. py:attribute:: connections5
      :value: 0



   .. py:attribute:: connections6
      :value: 0



   .. py:attribute:: connections7
      :value: 0



   .. py:attribute:: connections8
      :value: 0



   .. py:attribute:: __helper1
      :value: 0



   .. py:attribute:: __helper2
      :value: 0



   .. py:attribute:: __helper3
      :value: 0



   .. py:attribute:: propensity_pos
      :value: 0



   .. py:attribute:: propensity_neg
      :value: 0



   .. py:attribute:: firing_pos
      :value: 0



   .. py:attribute:: resting_pos
      :value: 0



   .. py:attribute:: firing_neg
      :value: 0



   .. py:attribute:: resting_neg
      :value: 0



   .. py:attribute:: fire_amt_pos
      :value: 0



   .. py:attribute:: fire_amt_neg
      :value: 0



   .. py:attribute:: fire_amt_mult_pos
      :value: 0



   .. py:attribute:: fire_amt_mult_neg
      :value: 0



   .. py:attribute:: propensity
      :value: 0



   .. py:method:: __init()


   .. py:method:: __check_cuda()


   .. py:method:: copy(model)

      Copy a model's data to a new model.

      :Parameters:
      model (general): the model to copy

      :Returns:
      none



   .. py:method:: create(size: int, image_size: int, bounds: int, num_controls: int, num_sensations: int)

      Create the model, a potentially time consuming process.

      :Parameters:
      size (int): the number of neurons to use
      image_size (int): the size of the input image to use
      bounds (int): the limit of how large values in the personality traits can get
      num_controls (int): how many control neurons you want
      num_sensations (int): how many sensation neurons you want

      :Returns:
      none

      :Comments:
      If the cuda check fails, it throws an error. This function is what actually initializes the model.
      On init doesn't really do anything, and sometimes we want to create a blank model without
      going through the lengthy process of initializing all its values and saving them to the GPU.
      Use this to actually create the model before you start using it.




   .. py:method:: __convert_tensor_to_nparray(tensor) -> numpy.ndarray


   .. py:method:: save(path)

      Save the model's data to disk.

      :Parameters:
      path (string): relative path from the location it's called at.

      :Returns:
      none

      :Comments:
      Saves the model's data to the harddisk for retrieval later. Wherever you ran a python file to call this function
      is the directory that this function will use to look for its path. There isn't any real searching involved here,
      so make sure the path you're looking for exists in that directory before you try to use this.



   .. py:method:: load(path)

      Load a model from storage.

      :Parameters:
      path (string): relative path from the location it's called from.

      :Returns:
      none

      :Comments:
      Currently we offload the functionality of saving data to the disk to NumPy. Eventually that will be fixed
      and included in tensorplus, but for now it just means that loading is slow. Also, be aware that 
      there's no real searching your system PATH variable for this directory. You just need to run your python program
      from the right directory in the first place.



   .. py:method:: __new_range(r: int)

      This function is currently not used.



   .. py:method:: __new_helpers()

      Initializes the helper variables that we use in the update function to carry
      values between function calls.



   .. py:method:: __new_propensity()

      Creates the propensity values.
      :Parameters:
      none

      :Returns:
      none

      :Comments:
      The propensity is used to determine the potential sizes of the personality values. It's basically
      an upper and lower limit on how large values in the model will get.



   .. py:method:: __new_image_map()

      Creates the image map.

      :Parameters:
      none

      :Returns:
      none

      :Comments:
      The image map is what allows us to take an image smaller than the number of neurons and send the color values
      from that image to the neurons they're supposed to go to. The map will usually contain the numbers 1, 2, 3... n-2, n-1, n ,
      where n is the size of the image to be mapped. Those numbers will go in the first n indexes of the image map, the rest of the values will between
      simply 0. We later use this as a set of vectors for the image to the neurons, with the 0 values discarded.



   .. py:method:: __new_thresholds()

      Creates the thresholds for the neurons.

      :Parameters:
      none

      :Returns:
      none

      :Comments:
      Contains values that correspond to the neurons and which signify the point at which the neuron will fire.
      When this value is exceeded either positively for the positive thresholds, or vice versa for the negatives,
      the neuron will fire and send its signal to each of its connected neurons (in the update() function).
      Here we initialize these threshold values to random values using a random generator from NumPy.



   .. py:method:: __new_controls()

      Creates the control neurons.

      :Parameters:
      none

      :Returns:
      none

      :Comments:
      The control neurons are what allows the model to interact with its environment. Whenever the value at a control neuron
      exceeds its threshold, either positively or negatively, it will fire the neuron and take an action that has been
      programmatically assigned to it in a higher level codespace. Here we initialize them to random neurons.



   .. py:method:: __new_connections()

      Creates the neuron connection vectors.

      :Parameters:
      none

      :Returns:
      none

      :Comments:
      The connections are vectors that map the neurons to other neurons. Whenever a given neuron fires, it sends its signal value to
      each other neuron that it's connected to. Note that connections are one-way and not necessarily reversible - indeed, most of the time 
      neurons won't be reciprocally connected unless it happens at random.



   .. py:method:: __new_personality()

      Creates a new personality for the model.

      :Parameters:
      none

      :Returns:
      none

      :Comments:
      The personality is what allows the model to have both persistent memory and a predefined way it reacts to information.
      This will take some explaining:

      First of all, the personality values are static in the model. During operation they don't change. These are roughly analogous 
      to the model weights that are used in typical deep learning neural networks. We iterate on the personality values in order
      to create new models and test them against the ones we already have.

      To describe the whole process, when a neuron fires in the update function, it uses a threshold value and a signal value. 
      Whenever a threshold value or a signal value is used, that value gets modified 
      by a corresponding emotion value - we simply add the emotion value to the threshold or signal value that's 
      in that spot. The catch is that when a threshold value or signal value is NOT used, we ALSO modify that value by a Different emotion value. 
      Here, it looks like this:

      -----

      if a neuron fires positively, threshold_pos and signal_pos are used, while threshold_neg and signal_neg are NOT used
      if a neuron fires negatively, threshold_pos and signal_pos are used, while threshold_pos and signal_pos are NOT used 
      if a neuron does not fire at all, neither the positive or negative thresholds and signals are used 

      Then:
      if threshold_pos is used, emotion1 is added to it
      if threshold_pos is NOT used, emotion2 is added to it 

      if threshold_neg is used, emotion3 is added to it 
      if threshold_neg is NOT used, emotion4 is added to it 

      if signal_pos is used, emotion5 is added to it 
      if signal_pos is NOT used, emotion6 is added to it 

      if signal_neg is used, emotion7 is added to it 
      if signal_neg is NOT used, emotion8 is added to it 

      -----

      To continue the explanation, this isn't the end of what we do when a neuron fires. We also repeat this process in a similar
      manner for the emotion layers. In much the same way, if an emotion is added to its corresponding threshold or signal, then 
      we add a certain personality value to it, and if it is NOT added to its corresponding threshold or signal, then we add a 
      different personality value to it. It'll look like this:

      -----

      if emotion1 is used, personality1 is added to it 
      if emotion1 is NOT used, personality2 is added to it 

      if emotion2 is used, personality3 is added to it 
      if emotion2 is NOT used, personality4 is added to it 

      if emotion3 is used, personality5 is added to it 
      if emotion3 is NOT used, personality6 is added to it 

      if emotion4 is used, personality7 is added to it 
      if emotion4 is NOT used, personality8 is added to it 

      if emotion5 is used, personality9 is added to it 
      if emotion5 is NOT used, personality10 is added to it 

      if emotion6 is used, personality11 is added to it 
      if emotion6 is NOT used, personality12 is added to it 

      if emotion7 is used, personality13 is added to it 
      if emotion7 is NOT used, personality14 is added to it 

      if emotion8 is used, personality15 is added to it 
      if emotion8 is NOT used, personality16 is added to it 

      -----

      This elaborate process might seem unnecessary, but it is the hypothesis central to this project that this process
      will allow the model to retain memory of its environment and its own actions while simultaneously allowing it to 
      both act in a predictable, deterministic manner AND to allow it to modify or change its own behavior when presented
      with the same circumstances again.

      This means that, hopefully, this process will allow the model to have memory and to learn. For a full explanation of 
      why this might work, I'll be writing a white paper on this project soon.




   .. py:method:: __new_sensations()

      Create the sensation neurons.

      :Parameters:
      none

      :Returns:
      none

      :Comments:
      The sensation neurons allow the user to give feedback to the model on how it is performing at its task 
      and on what its environment is like. It's up to the user to find create and useful implementations 
      for the sensation feature. Ideally, you would use it as a reward and punishment system, use it to indicate 
      the presence or absense of goals or threats, to allow the model to sense objects in its environment, etc. 
      This needs to be handled programmatically in the higher level codespace.



   .. py:method:: __pos_sensation(sense_num: int, amt: int)

      Creates the positive sensation neurons

      :Parameters:
      none

      :Returns:
      none

      :Comments:
      For use in the __new_sensations() function.



   .. py:method:: __neg_sensation(sense_num: int, amt: int)

      Creates the negative sensation neurons

      :Parameters:
      none

      :Returns:
      none

      :Comments:
      For use in the __new_sensations() function.



   .. py:method:: feedback(sense_num: int, amt: int, pos: bool)

      Give the model feedback on how it is performing at its task.

      :Parameters:
      sense_num (int): which sensation to use for this feedback.
      amt (int): how big or small of a sensation it is.
      pos(bool): whether this is a positive or negative feedback.

      :Returns:
      none

      :Comments:



   .. py:method:: permute(fraction: int)

      Permute the model's personality by a certain degree.

      :Parameters:
      fraction (int): positive integer which lessens the degree of the permutation as it receives higher values

      :Returns:
      none

      :Comments: 
      You will absolutely need to trial and error with the degree to see what works best for your use case.
      This function will enable iterating on the personality traits of a model which has already proven useful.
      You'll want to use this to make small, incremental improvements to a model and then test it to see whether to move 
      forward with the changes or roll back to a previous version.

      If you want the model to change quickly, set the fraction to 1. That will be the fastest it can change currently.
      If you want the model to change slowly (and in most cases you will want this), set the fraction
      to higher numbers. The higher fraction goes, the slower the model will change with each iteration.

      Once a minimal working model has been found, this function will be what we primarily use to iterate on it.



   .. py:method:: __convert_nparray(nparray: numpy.ndarray)

      Converts a NumPy array to a TensorPlus tensor.

      :Parameters:
      nparray (numpy.ndarray): the array to be converted.

      :Returns:
      tensor (tensorplus.tensor): the converted tensor.

      :Comments:
      This is a bit of a slow process. Converting tensors to numpy arrays and vice versa is a significant
      performance bottleneck for the library currently. Eventually I'll want to replace everything 
      we're using NumPy for with TensorPlus functions, but we're not there yet.



   .. py:method:: update(input_image: numpy.ndarray) -> list[bool]

      The main logic loop for using the model requires running this function for it to act.

      :Parameters:
      input_image: a NumPy array which is the same size as the model's image size

      :Returns:
      take_action: a list of booleans which represents which actions the model is taking with this update.

      :Comments:
      The logic for how this function works is as follows:

      Step 1
      Take the input image and resize it, then use it as starting values for the first layer

      Step 2
      Compare the neurons values to the positive and negative thresholds to determine which neurons are firing.

      Step 3
      Send the signals of each neuron to each of its connected neurons.

      Step 4
      Update the emotion layers by adding in their relevant personality layer. 

      Step 5 
      Check the control neurons to determine if any of them are firing. If they are, set it to true in the 
      output of the update function, if not, set it to false



